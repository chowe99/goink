name: CI Pipeline

on:
  push:
    branches:
      - master  
      - develop
  pull_request:
    branches:
      - master
      - develop

jobs:
  build-and-test:
    runs-on: ubuntu-latest
    env:
      DB_HOST: '127.0.0.1'

    services:
      db:
        image: postgres:13
        env:
          POSTGRES_DB: ${{ secrets.POSTGRES_DB }}
          POSTGRES_USER: ${{ secrets.POSTGRES_USER }}
          POSTGRES_PASSWORD: ${{ secrets.POSTGRES_PASSWORD }}
        ports:
          - 5432:5432
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 10
          --health-start-period 20s

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.9'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt

      - name: Debug- Check hosts
        run: |
          echo "Hosts file:"
          cat /etc/hosts

      - name: Debug- Network inspection
        run: |
          echo "Network interfaces:"
          ifconfig || ip addr
          echo "Ping DB container:"
          ping -c 4 db || echo "DB not reachable"
          echo "DNS lookup for 'db':"
          nslookup db || echo "DNS lookup failed"
          echo "Checking open ports:"
          netstat -tuln || ss -tuln

      - name: Debug- Check Docker network
        run: |
          docker network inspect ${{ job.services.db.network }}

      - name: Debug- Test connectivity to the DB service using curl
        run: |
          echo "Testing connectivity to the DB service using curl..."
          DB_CONTAINER=$(docker ps --filter "label=db=goink_db" --format "{{.Names}}")
          if [ -n "$DB_CONTAINER" ]; then
            docker exec $DB_CONTAINER curl -s http://db:5432 || echo "Failed to connect to DB"
          else
            echo "DB container not found."
            docker ps -a  # List all containers for debugging
          fi

      - name: Wait for PostgreSQL to be ready
        run: |
          echo "Testing connection to PostgreSQL"
          timeout=60  # Set a timeout (in seconds)
          while ! pg_isready -h 127.0.0.1 -p 5432; do
            echo "Waiting for PostgreSQL..."
            sleep 3
            timeout=$((timeout - 3))
            if [ $timeout -le 0 ]; then
              echo "Timeout reached while waiting for PostgreSQL."
              exit 1
            fi
          done

      - name: Apply migrations
        run: python manage.py migrate

      - name: Run tests
        run: python manage.py test

      - name: Log in to Docker Hub
        uses: docker/login-action@v2
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: Check PostgreSQL logs if failure
        if: failure()
        run: |
          docker logs ${{ job.services.db.id }}

      - name: Install jq
        run: sudo apt-get install -y jq

      - name: Get remote Docker image digest
        id: remote_digest
        run: |
          # Attempt to pull the latest image; if it doesn't exist, handle gracefully
          docker pull chowewow/goink:latest || echo "Image does not exist yet."
          
          # Retrieve the RepoDigest of the remote image
          remote_digest=$(docker image inspect chowewow/goink:latest --format='{{index .RepoDigests 0}}' || echo "none")
          
          # Extract only the digest part
          remote_digest_only=$(echo $remote_digest | cut -d'@' -f2)
          
          echo "digest=$remote_digest_only" >> $GITHUB_ENV
        continue-on-error: true

      - name: Build local Docker image
        id: local_digest
        run: |
          docker build -t chowewow/goink:latest .
          
          # Retrieve the RepoDigest of the local image
          local_digest=$(docker image inspect chowewow/goink:latest --format='{{index .RepoDigests 0}}' || echo "none")
          
          # Extract only the digest part
          local_digest_only=$(echo $local_digest | cut -d'@' -f2)
          
          echo "local_digest=$local_digest_only" >> $GITHUB_OUTPUT

      - name: Compare image digests
        id: compare
        run: |
          if [ "${{ env.digest }}" == "${{ steps.local_digest.outputs.local_digest }}" ]; then
            echo "Images are the same, pulling the image."
            echo "build_needed=false" >> $GITHUB_OUTPUT
          else
            echo "Images are different, building and pushing the image."
            # Sanitize the ref name by replacing slashes with hyphens
            sanitized_ref=$(echo "${GITHUB_REF#refs/heads/}" | tr '/' '-')
            echo "sanitized_ref=$sanitized_ref" >> $GITHUB_ENV
            echo "build_needed=true" >> $GITHUB_OUTPUT
          fi

      - name: Pull or push Docker image based on comparison
        run: |
          if [ "${{ steps.compare.outputs.build_needed }}" == "true" ]; then
            # Tag the image with the sanitized branch name and commit SHA
            docker tag chowewow/goink:latest chowewow/goink:${{ env.sanitized_ref }}
            docker tag chowewow/goink:latest chowewow/goink:${{ github.sha }}
            
            # Push the tagged images
            docker push chowewow/goink:latest
            docker push chowewow/goink:${{ env.sanitized_ref }}
            docker push chowewow/goink:${{ github.sha }}
          else
            # Pull the existing image to ensure it's up to date
            docker pull chowewow/goink:latest
          fi

      - name: Check PostgreSQL container logs if failed
        if: failure()
        run: |
          docker logs ${{ job.services.db.id }}

  deploy:
    needs: build-and-test
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/master'  # Only deploy from master branch

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Set up SSH
        uses: webfactory/ssh-agent@v0.5.4
        with:
          ssh-private-key: ${{ secrets.SSH_KEY }}

      - name: Deploy to Server
        env:
          DOCKER_USERNAME: ${{ secrets.DOCKER_USERNAME }}
          POSTGRES_DB: ${{ secrets.POSTGRES_DB }}
          POSTGRES_USER: ${{ secrets.POSTGRES_USER }}
          POSTGRES_PASSWORD: ${{ secrets.POSTGRES_PASSWORD }}
          DJANGO_SETTINGS_MODULE: ${{ secrets.DJANGO_SETTINGS_MODULE }}
        run: |
          ssh ${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }} << 'EOF'
            cd /path/to/your/app || exit 1
            docker-compose pull || exit 1
            docker-compose up -d || exit 1
            docker-compose exec web python manage.py migrate || exit 1
          EOF

